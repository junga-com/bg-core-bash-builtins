#!/usr/bin/env bash

# The goal of this configure script is...
#     1) install the bash headers and loadable builtin Makefile.inc. On debian based distros this is the bash-builtins pacakge.
#     2) locate the builtin Makefile.inc. On debian based distros this is at /usr/lib/bash/Makefile.inc
#     3) copy that Makefile.inc to this project folder as Makefile and modify it to replace the example.c builtin target with
#        the builtin taget(s) contained in this project.
#

# this is a space separated list of folders where a distro might place the loadable builtin makefile.
# it might alsways be /usr/lib/bash but just in case your distro does it differently, here is the place to add that info
pathsToTry="/usr/lib/bash"

function assertError() {
	echo "$*" >&2
	exit 2
}

# fills in var 'makefileLocation' if succesful
function searchForMakefile() {
	for pathToTry in /usr/lib/bash; do
		if [ -f "${pathToTry}"/Makefile.inc ]; then
			makefileLocation="${pathToTry}"/Makefile.inc
			break
		fi
	done
}

# To support a new distro, add a new elif block for that distro's package manager command to install the package contained in $1
function installDependency() {
	echo "installing dependency '$1'"
	if type -t apt-get &>/dev/null; then
		sudo apt-get install -y "$1"
	# elif type -t yum &>/dev/null; then
	# 	yum install -y "$1"
	else
		cat <<-EOS
			This distro is not yet supported by this configure script because it does not know how to install the dependency
			'$1' You can manually install that dependency and then re-run this command.
			EOS
	fi
}

# allow the caller to provide the path to the Makefile.inc
if [ "$1" ]; then
	makefileLocation="${1%/Makefile.inc}/Makefile.inc"
	[ -f "$makefileLocation" ] || {
		assertError "The Makefile.inc location provided as the first argument does not exist" >&2
	}
else
	searchForMakefile
fi

# if not found, try to install the bash builts/headers
[ -f "$makefileLocation" ] || {
	installDependency bash-builtins
	searchForMakefile
}

# if still not found, error out
[ -f "$makefileLocation" ] || {
	assertError <<-EOS
		Could not find the bash loadable builtin Makefile.inc on this host which is needed to build this project.
		You can manually install the bash-builtin/headers from a package from your distro or by downloading and builing the bash
		source and then re-run this command.

		If the builtins Makefile is not installed to /usr/lib/Makefile.inc, pass the full path to it as the first argument to
		this command.
		EOS
}

type -t awk &>/dev/null || installDependency awk
type -t awk &>/dev/null || assertError "This command needs 'awk' to modify the Makefile.inc from the bash project to become this project's makefile"

builtinList="$(ls -1 *.c 2>/dev/null)"

[ "$builtinList" ] || {
	assertError "No <builtin>.c files found in this project. It is assumed that <builtin>.c will be in the root project folder"
}


makeScript='
# the intermediate <builtinName>.o files will be placed in the $(OBJ) folder. It can be set to empty or ./ to put them in the top folder
# if OBJ is not empty, it must end in a /
# If OBJ is empty, make will consider <builtinName>.o intermediate files and remove them after the target is built
#OBJ = bin/obj/
#OBJ = .bglocal/obj/
#OBJ =

# the <builtinName>.so output files will be placed in the $(BIN) folder. It can be set to empty or ./ to put them in the top folder
# if BIN is not empty, it must end in a /
#BIN =
BIN = bin/

OUTPUTFILES = %builtinSOList%

INSTALLDIR = $(DESTDIR)/usr/lib/bash

# tell make to forget all of its default implicit rules. we want to specify the cmdline for everything we build
.SUFFIXES:

# tell make to run the entire recipe as one script
.ONESHELL:

all: $(OBJ) $(BIN) $(OUTPUTFILES)

$(BIN) $(OBJ) $(INSTALLDIR) :
	mkdir -p $@

# Note: This implicit .c to .o rule builds it as a shared object. If we support libraries, we probably will have to
# change this to distinguish between the .c which are the main builtins and others which are modules that will be linked in.
# this recipe should be the same cmd as in the ".c.o:" target of examples/loadables/Makefile.inc except the output is "$(OBJ)$@" instead of "$@"
%.o : %.c
	%compilerCommand%

# this recipe should be the same cmd as in the "example:" target of examples/loadables/Makefile.inc except the input is "$(OBJ)$<" instead of "example.o"
$(BIN)%.so : %.o
	%linkerCommand%


clean:
	-@$(RM) $(OBJ)*.o  $(BIN)*.so
	rmdir bin 2>/dev/null

install: $(INSTALLDIR) all
	prefixCmd=""; [ ! -w "$(INSTALLDIR)" ] && prefixCmd="sudo "
	$$prefixCmd cp  $(OUTPUTFILES) $(INSTALLDIR)

.DELETE_ON_ERROR:
.PHONEY: all clean install
'


# copy and modify the Makefile.inc
echo "$builtinList" | awk -v makeScript="$makeScript" '
	@include "bg_core.awk"
	BEGIN {
		printf("# WARNING: This file is overwritten each time you run ./configure so you probably dont want to edit it directly \n");
		while ((getline builtinSource <"/dev/stdin") >0) {
			builtinList[builtinSource]=1
		}
		# set these equal to the cmdline from the ".c.o:" and "example:" targets respectively from the /usr/lib/bash/Makefile.inc
		# if they change
		compilerCommand="	$(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) $(INC) -c -o $@ $<";
		linkerCommand="	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ example.o $(SHOBJ_LIBS)";
	}

	# capture all lines up until the targets that we will replace
	# assume that all: is still at the bottom and that it and everything below it is specific to the example.c builtin (that we will remove)
	$1=="all:"  {stopCopying=NR}
	$1==".c.o:" {stopCopying=NR}
	$1~/^[^[:space:]]+[[:space:]]?:[^=]/ {stopCopying=NR}
	stopCopying=="" {origLines[NR]=$0}

	# its ok if the input Makefile.inc no longer has this target but if it does, we print a warning if it has changed
	# catpure the build command for the building example: from example.o so that we can modify it to be general (an implicit rule)
	$1==".c.o:" {
		getline
		if (compilerCommand != $0)
			printf("WARNING: the compiler %s command under the '%s' target has changed since this configure script was written. You may need to update the '%s' rule in ./configure \n", "build", $1, "%.o : %.c") > "/dev/stdout"
		compilerCommand=$0
	}

	# its ok if the input Makefile.inc no longer has this target but if it does, we print a warning if it has changed
	# catpure the build command for the building example: from example.o so that we can modify it to be general (an implicit rule)
	$1=="example:" {
		getline
		if (linkerCommand != $0)
			printf("WARNING: the %s build command under the '%s' target has changed since this configure script was written. You may need to update the '%s' rule in ./configure \n", "linker", $1, "$(BIN)%.so : %.o") > "/dev/stdout"
		linkerCommand=$0
	}

	END {
		# thes commands come from the original Makefile.inc but we need to fixup the input/output to be generic and in the $(OBJ) folder
		compilerCommand=gensub(/[$][@]/,   "$(OBJ)$@", "g",compilerCommand);
		linkerCommand  =gensub(/example.o/,"$(OBJ)$<", "g",linkerCommand);

		makeScript=gensub(/%compilerCommand%/,compilerCommand,"g",makeScript);
		makeScript=gensub(/%linkerCommand%/,  linkerCommand,  "g",makeScript);

		builtinSOList=""
		for (builtinName in builtinList)
			builtinSOList=builtinSOList" $(BIN)"gensub(/[.]c$/,".so","g",builtinName)
		makeScript=gensub(/%builtinSOList%/,  builtinSOList,  "g",makeScript);


		# if the Makefile.inc no longer has an explicit all: rule, then we can use it as a an include file.
		if (!stopCopying) {
			printf("\ninclude %s\n\n", FILENAME);

		# otherwise, copy the original Makefile.inc up to the point that it starts defining the targets
		} else {
			for (i=0; i<=stopCopying; i++)
				printf("%s\n",origLines[i]);
		}

		# print our script at the end
		printf("%s\n", makeScript);
	}
' "$makefileLocation" > ./Makefile
result=$?

if [ $result -ne 0 ]; then
	assertError <<-EOS
		the awk command that modifies '$makefileLocation' to become './Makefile' exited with the error code '$result'.
		You can try to copy and modify that Makefile yourself. Typically search and replace the 'example' builtin with the
		name of the built(s) from this project.
		EOS
else
	echo "Success"
fi
echo
